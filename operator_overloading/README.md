# [C++] operator_overloading
学习下 `C++` 中的运算符重载, 主要示例来源于《C++ Primer 5th》 第14章重载运算与类型转换.   


## Read & Run
仅在linux下进行了实验, 都是通用代码, 理论上平台无关. 顺便熟练下`vim`的使用.    
- `Linux`: `CentOS7 64bit`   
			- `Kernel 3.10.0-229.el7.x86_64`   
			- `gcc 4.8.5 20150623`   
			- `VIM - Vi IMproved 7.4 (2013 Aug 10, compiled Jun 10 2014 06:55:55)`    

	- 阅读  
		- `vim -S SalesData_session.vim`   
		- `vim -S StrVec_session.vim`   

	- 编译与运行   
		```
		g++ -std=c++11 SalesData.cc StrVec.cc main.cc    
		./a.out   
		```   

## 实验说明   

- main.cc   
入口代码.   

- SalesData.h/cc   
示例的类, 对齐进行了各种运算符重载以方便使用.   

- 关键点   
	- 重载运算符函数的参数数量与该运算符作用的运算对象一样多:   
		- 一元运算符有一个参数, 二元运算符有两个   
		- 对于二元运算符来说, 左侧运算对象传递给第一个参数, 而右侧运算符对象传递给第二个参数   
		- 如果一个运算符函数是成员函数, 则它的第一个(左侧)运算对象绑定到隐式的this指针上, 因此, 成员运算符函数(显式)参数数量比运算符的运算对象总数少一个   
		- 对于一个运算符函数来说, 它或者是类的成员, 或者至少含有一个类类型的参数   
		- 有四个符号(`+`, `-`, `*`, `&`)即是一元运算符也是二元运算符, 它们都能被重载, 从参数的数量可以推断到底定义的是哪种   
	- 我们只能重载已有的运算符, 而不能发明新的运算符   
		- 已有的运算符中不能被重载的:  
			`::`, `.*`, `.`, `?:`  
			其他所有运算符都能被重载   
	- 重载的运算符函数可以让运算符作用于类型正确的实参从而间接地调用, 也可以像普通函数一样显式调用.   
	- 不应该被重载的操作符:   
		`&&` `||` `,` `&`   
		- 运算求值顺序规则无法保留下来   
		- 无法保留内置运算符的短路求值属性   
		- 应用于类类型对象时有特殊含义(取地址)   
	- 只有当操作的含义对于用户来说清晰明了时才去重载运算符. 如果用户对于运算符可能有几种不同的理解, 则重载运算符将产生二义性, 不应重载.   
	- 重载运算符时, 选择作为成员函数或非成员的一些准则:   
		- 赋值`=`, 下标`[]`, 调用`()`和成员访问箭头`->`必须是成员   
		- 复合赋值运算符一般来说应该是成员(其修改了对象状态), 但并非必须   
		- 改变对象状态的运算符或者与给定类型关系密切相关的运算符, 如递增、递减和解引用, 通常应该是成员   
		- 具有对称性的运算符可能转换任意一端的运算对象, 如算术、相等性、关系和位运算符等, 通常应该是普通的非成员函数   

- 杂项   
	- 复合赋值运算符, 如`operator +=`, 既可以定义为类的成员函数, 也可以定义为普通的函数, 未调用时可以同时定义, 但一旦有调用代码就会分不清重载的哪个. 定义为类的成员函数, 实现上会更方便, 使用上没有区别. 故定义为类的成员函数更好.      
	- 输入运算符`>>`重载时, 应注意检查并处理输入错误.   
	- `C++11`在传递`const T& a`时, 要求`a`只能调用带`const`标示的函数, 否则默认会报`error: passing ‘xxx’ as ‘this’ argument of ‘xxxxx’ discards qualifiers [-fpermissive]`, 需要注意   
	- 定义`operator[]`重载时, 最好同时定义其常量版本与非常量版本, 当作用于一个常量对象时, 下标运算符返回常量引用以确保我们不会给返回的对象赋值.   
	- 定义`operator++/--`重载时  
		- 应同时定义前置版本和后置版本, 通常应定义为类的成员函数.   
		- 为了与内置版本保持一致, 前置运算符应返回递增/递减后对象的引用, 后置运算符应返回递增/递减前的临时对象   
		- 区分前置与后置版本的规则: 后置版本接受一个额外的(不被使用的)int类型的形参, 使用时编译器为这个形参提供一个值为0的实参   

## Reference Links


### Contacts
Author's Email: wangyoucao577@gmail.com.
